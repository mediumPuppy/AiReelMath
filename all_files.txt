// lib/widgets/video_feed_item.dart
// ================================================================================
import 'package:flutter/material.dart';
import 'dart:async';
import '../models/video_feed.dart';
import '../services/firestore_service.dart';
import '../services/topic_progress_service.dart';
import '../services/video_progress_tracker.dart';
import 'action_bar.dart';
import '../screens/ai_explanation_screen.dart';
import '../controllers/json_video_controller.dart';
import '../widgets/geometry_drawing_painter.dart';
import '../models/drawing_spec_models.dart';
import '../utils/handwriting_util.dart';
import '../services/speech_service.dart';

class VideoFeedItem extends StatefulWidget {
  final int index;
  final VideoFeed feed;
  final VoidCallback onShare;
  final PageController pageController;
  final String userId;
  final VideoProgressTracker progressTracker;
  final VoidCallback? onQuizComplete;

  const VideoFeedItem({
    super.key,
    required this.index,
    required this.feed,
    required this.onShare,
    required this.pageController,
    required this.userId,
    required this.progressTracker,
    this.onQuizComplete,
  });

  @override
  State<VideoFeedItem> createState() => _VideoFeedItemState();

  // Add a static method to start playback
  static void startPlayback(BuildContext context) {
    final state = context.findAncestorStateOfType<_VideoFeedItemState>();
    if (state != null) {
      state._startPlayback();
    }
  }

  // Add a static method to stop playback
  static void stopPlayback(BuildContext context) {
    final state = context.findAncestorStateOfType<_VideoFeedItemState>();
    if (state != null) {
      state._stopPlayback();
    }
  }
}

class _VideoFeedItemState extends State<VideoFeedItem>
    with SingleTickerProviderStateMixin {
  final _progressService = TopicProgressService();
  final SpeechService _speechService = SpeechService();
  StreamSubscription? _positionSubscription;
  late JsonVideoController _jsonController;
  bool _isInitialized = false;
  bool _showTransition = false;
  late ScrollController _innerScrollController;
  bool _hasTriggeredPageTurn = false;
  static const double _scrollThreshold = 100.0;
  double _overscrollAmount = 0.0;
  late AnimationController _animationController;
  bool _isSpeaking = false;
  bool _isPageTransitionComplete = false;

  @override
  void initState() {
    super.initState();
    _jsonController = JsonVideoController(videoJson: widget.feed.videoJson);
    _initializeJsonVideo();
    _innerScrollController = ScrollController();
    _animationController = AnimationController(
      vsync: this,
      duration: Duration(
          seconds: (widget.feed.videoJson['instructions']['timing']
                  .last['endTime'] as num)
              .round()),
    );

    // Add page controller listener to detect when transition is complete
    widget.pageController.addListener(_onPageScroll);

    // Start playback for first video immediately if we're at index 0
    if (widget.index == 0) {
      // Use a post-frame callback to ensure the widget is mounted
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        setState(() {
          _isPageTransitionComplete = true;
        });

        // Track video and check for quiz before starting playback
        widget.progressTracker.trackVideo(widget.feed);

        // Reset animation to start and ensure it's paused
        _animationController.reset();
        _speechService.pause();

        final shown =
            await widget.progressTracker.shouldShowQuiz(context, widget.userId);

        // Only start playback if no quiz was shown
        if (!shown && mounted) {
          _startPlayback();
        }
      });
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _positionSubscription?.cancel();
    _positionSubscription = _progressService.positionStream.listen((position) {
      if (mounted) setState(() {});
    });
  }

  Future<void> _initializeJsonVideo() async {
    await _jsonController.initialize();
    if (!mounted) return;
    setState(() {
      _isInitialized = _jsonController.isInitialized;
    });
  }

  void _handleLike() {
    final firestoreService = FirestoreService();
    firestoreService.toggleVideoLike(widget.feed.id);
  }

  void _handleExplain() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AIExplanationScreen(
          videoContext: widget.feed,
          videoObject: widget.feed.toJson(),
        ),
      ),
    );
  }

  void _togglePlayPause() {
    print(
        '_togglePlayPause called - animation state: ${_animationController.isAnimating}');
    if (_animationController.isAnimating) {
      print('Stopping animation and audio');
      _animationController.stop();
      _speechService.pause();
    } else {
      print('Starting animation from: ${_animationController.value}');
      _animationController.forward(from: _animationController.value);
      if (_isSpeaking) {
        print('Resuming existing speech');
        _speechService.resume();
      } else {
        print('Starting speech since not currently speaking');
        _startSpeech();
      }
    }
  }

  void _startSpeech() async {
    print('_startSpeech called');
    final speechData = widget.feed.videoJson['instructions']['speech'];
    final script = speechData['script'] as String;
    final preGeneratedMp3Url = speechData['mp3_url'] as String?;

    print(
        'Speech script: ${script.substring(0, script.length > 50 ? 50 : script.length)}...');
    if (script.isNotEmpty) {
      setState(() {
        _isSpeaking = true;
      });
      try {
        await _speechService.speak(script,
            preGeneratedMp3Url: preGeneratedMp3Url);

        // Listen for playback completion
        if (_speechService.isPlaying) {
          while (_speechService.isPlaying) {
            await Future.delayed(const Duration(milliseconds: 100));
          }
          if (mounted) {
            setState(() {
              _isSpeaking = false;
            });
          }
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isSpeaking = false;
          });
        }
      }
    }
  }

  void _onPageScroll() async {
    // Check if we're at a whole number page index (transition complete)
    if (widget.pageController.page?.round() == widget.index &&
        !_isPageTransitionComplete &&
        (widget.pageController.page! - widget.index).abs() < 0.01) {
      setState(() {
        _isPageTransitionComplete = true;
      });

      // Track video for quiz scheduling first
      widget.progressTracker.trackVideo(widget.feed);

      // Reset animation to start and ensure it's paused
      _animationController.reset();
      _speechService.pause();

      // Check if we should show a quiz before starting playback
      print(
          '[VideoFeed] Checking if should show quiz for user: ${widget.userId}');
      final shown =
          await widget.progressTracker.shouldShowQuiz(context, widget.userId);
      print('[VideoFeed] Quiz shown: $shown');

      // Only start playback if no quiz was shown
      if (!shown && mounted) {
        _startPlayback();
      } else if (shown && mounted && widget.onQuizComplete != null) {
        // Register the callback to start playback after quiz
        widget.onQuizComplete!();
      }
    }

    // Pause playback during scrolling if this is the current page
    if (widget.pageController.page?.round() == widget.index) {
      final isScrolling =
          (widget.pageController.page! - widget.index).abs() > 0.01;
      if (isScrolling && _animationController.isAnimating) {
        _animationController.stop();
        _speechService.pause();
      } else if (!isScrolling &&
          !_animationController.isAnimating &&
          _isPageTransitionComplete) {
        _animationController.forward();
        _speechService.resume();
      }
    }
  }

  void _startPlayback() {
    if (mounted) {
      // Always start from beginning
      _animationController.reset();
      _animationController.forward();
      _startSpeech();
    }
  }

  void _stopPlayback() {
    if (mounted) {
      // Stop the animation
      _animationController.stop();
      // Also stop the audio
      _speechService.pause();

      setState(() {
        _isSpeaking = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final firestoreService = FirestoreService();

    return GestureDetector(
      onTap: _togglePlayPause,
      child: Stack(
        fit: StackFit.expand,
        children: [
          AnimatedBuilder(
            animation: _animationController,
            builder: (context, child) {
              final currentTime = _animationController.value *
                  widget
                      .feed.videoJson['instructions']['timing'].last['endTime']
                      .toDouble();
              return Container(
                color: Colors.white,
                child: NotificationListener<ScrollNotification>(
                  onNotification: (notification) {
                    if (notification is ScrollUpdateNotification) {
                      // Pause playback when scrolling starts
                      if (_animationController.isAnimating) {
                        _animationController.stop();
                        _speechService.pause();
                      }

                      if (_innerScrollController.position.pixels >=
                              _innerScrollController.position.maxScrollExtent &&
                          notification.metrics.pixels >=
                              notification.metrics.maxScrollExtent) {
                        _overscrollAmount += notification.scrollDelta ?? 0;
                      } else if (_innerScrollController.position.pixels <=
                              _innerScrollController.position.minScrollExtent &&
                          notification.metrics.pixels <=
                              notification.metrics.minScrollExtent) {
                        _overscrollAmount += notification.scrollDelta ?? 0;
                      } else {
                        _overscrollAmount = 0;
                      }

                      if (_overscrollAmount.abs() >= _scrollThreshold &&
                          !_hasTriggeredPageTurn) {
                        _hasTriggeredPageTurn = true;
                        if (_overscrollAmount > 0) {
                          widget.pageController.nextPage(
                            duration: const Duration(milliseconds: 500),
                            curve: Curves.easeOutCubic,
                          );
                        } else {
                          widget.pageController.previousPage(
                            duration: const Duration(milliseconds: 500),
                            curve: Curves.easeOutCubic,
                          );
                        }
                        _overscrollAmount = 0;
                      }
                    } else if (notification is ScrollEndNotification) {
                      _hasTriggeredPageTurn = false;
                      _overscrollAmount = 0;
                    }
                    return false;
                  },
                  child: CustomPaint(
                    painter: GeometryDrawingPainter(
                      currentTime: currentTime,
                      specification: GeometryDrawingSpec(
                        stages: List<DrawingStage>.from(widget
                            .feed.videoJson['instructions']['timing']
                            .map((stage) => DrawingStage(
                                  stage: stage['stage'],
                                  startTime:
                                      (stage['startTime'] as num).toDouble(),
                                  endTime: (stage['endTime'] as num).toDouble(),
                                  description: stage['description'],
                                  easing: stage['easing'],
                                ))),
                        shapes: List<GeometryShape>.from(widget
                            .feed.videoJson['instructions']['drawing']['shapes']
                            .map((shape) => GeometryShape(
                                  id: shape['id'],
                                  vertices: shape['vertices']
                                          ?.map<Offset>((v) => Offset(
                                              (v['x'] as num).toDouble(),
                                              (v['y'] as num).toDouble()))
                                          ?.toList() ??
                                      [],
                                  path: shape['path'],
                                  style: shape['style'],
                                  strokeWidth:
                                      (shape['strokeWidth'] as num).toDouble(),
                                  color: _hexToColor(shape['color']),
                                  fadeInRange: (shape['fadeInRange'] as List)
                                      .map<double>((v) => (v as num).toDouble())
                                      .toList(),
                                ))),
                        labels: List<GeometryLabel>.from(widget
                            .feed.videoJson['instructions']['drawing']['labels']
                            .map((label) => GeometryLabel(
                                  id: label['id'],
                                  text: label['text'],
                                  position: Offset(
                                      (label['position']['x'] as num)
                                          .toDouble(),
                                      (label['position']['y'] as num)
                                          .toDouble()),
                                  color: _hexToColor(label['color']),
                                  fadeInRange: (label['fadeInRange'] as List)
                                      .map<double>((v) => (v as num).toDouble())
                                      .toList(),
                                  drawingCommands: label['handwritten'] == true
                                      ? generateHandwrittenCommands(
                                          label['text'],
                                          Offset(
                                              (label['position']['x'] as num)
                                                  .toDouble(),
                                              (label['position']['y'] as num)
                                                  .toDouble()))
                                      : null,
                                ))),
                        speechScript: widget.feed.videoJson['instructions']
                                ['speech']['script'] ??
                            '',
                        speechPacing: (widget.feed.videoJson['instructions']
                                        ['speech']['pacing']
                                    as Map<String, dynamic>? ??
                                {})
                            .map((key, value) =>
                                MapEntry(key, (value as num).toDouble())),
                      ),
                    ),
                    size: Size.infinite,
                  ),
                ),
              );
            },
          ),
          Positioned(
            right: 16,
            bottom: 100,
            child: StreamBuilder<bool>(
              stream: firestoreService.isVideoLiked(widget.feed.id),
              builder: (context, likedSnapshot) {
                return StreamBuilder<int>(
                  stream: firestoreService.getVideoLikesCount(widget.feed.id),
                  builder: (context, likesSnapshot) {
                    return ActionBar(
                      onLike: _handleLike,
                      onShare: widget.onShare,
                      onExplain: _handleExplain,
                      likes: likesSnapshot.data ?? widget.feed.likes,
                      shares: widget.feed.shares,
                      isLiked: likedSnapshot.data ?? false,
                      currentTopics: widget.feed.topics,
                    );
                  },
                );
              },
            ),
          ),
          Positioned(
            left: 16,
            right: 72,
            bottom: 16,
            child: Text(
              widget.feed.description,
              style: const TextStyle(color: Colors.black, fontSize: 16),
            ),
          ),
        ],
      ),
    );
  }

  Color _hexToColor(String hexColor) {
    final buffer = StringBuffer();
    if (hexColor.length == 7) {
      buffer.write('ff');
      buffer.write(hexColor.replaceFirst('#', ''));
    }
    return Color(int.parse(buffer.toString(), radix: 16));
  }

  @override
  void dispose() {
    widget.pageController.removeListener(_onPageScroll);
    _positionSubscription?.cancel();
    _jsonController.dispose();
    _innerScrollController.dispose();
    _animationController.dispose();
    _speechService.dispose();
    super.dispose();
  }
}



// lib/services/video_progress_tracker.dart
// ================================================================================
import 'package:flutter/material.dart';
import '../models/video_feed.dart';
import '../screens/quiz_screen.dart';
import '../services/quiz_scheduler_service.dart';
import 'package:collection/collection.dart';
import '../widgets/video_feed_item.dart';

class VideoProgressTracker {
  static const int videosBeforeQuiz = 2;
  final List<VideoFeed> _recentVideos = [];
  final QuizSchedulerService _quizScheduler = QuizSchedulerService();

  void trackVideo(VideoFeed video) {
    print('[VideoTracker] Adding video to tracker: ${video.title}');
    print(
        '[VideoTracker] Current video count before adding: ${_recentVideos.length}');

    _recentVideos.add(video);
    if (_recentVideos.length > videosBeforeQuiz) {
      print(
          '[VideoTracker] Removing oldest video as we exceeded $videosBeforeQuiz videos');
      _recentVideos.removeAt(0);
    }

    print(
        '[VideoTracker] Current videos tracked: ${_recentVideos.map((v) => v.title).join(", ")}');
  }

  Future<bool> shouldShowQuiz(BuildContext context, String userId) async {
    print('[VideoTracker] Checking if should show quiz...');
    print('[VideoTracker] Current video count: ${_recentVideos.length}');

    if (_recentVideos.length < videosBeforeQuiz) {
      print(
          '[VideoTracker] Not enough videos watched yet (${_recentVideos.length}/$videosBeforeQuiz)');
      return false;
    }

    // Get unique topics from recent videos
    final topics =
        _recentVideos.expand((video) => video.topics).toSet().toList();
    print('[VideoTracker] Topics collected for quiz: ${topics.join(", ")}');

    // Ensure we're mounted before proceeding
    if (!context.mounted) return false;

    // Stop the video playback before showing quiz
    VideoFeedItem.stopPlayback(context);

    // Show loading overlay with pause message first
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => WillPopScope(
        onWillPop: () async => false,
        child: const Center(
          child: Card(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text(
                    'Video Paused',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: Colors.grey,
                    ),
                  ),
                  SizedBox(height: 12),
                  Text(
                    'Quiz incoming...',
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text('Preparing your progress check'),
                ],
              ),
            ),
          ),
        ),
      ),
    );

    // Add a small delay to ensure the UI updates
    await Future.delayed(const Duration(milliseconds: 100));

    // Generate a quiz based on recent videos
    print('[VideoTracker] Generating quiz for user: $userId');
    final quiz = await _quizScheduler.generateQuizForUser(
      userId: userId,
      currentTopics: topics,
      previousVideos: _recentVideos,
      questionCount: 5, // Shorter quiz for between-video experience
    );

    // Close loading overlay
    if (context.mounted) {
      Navigator.of(context).pop();
    }

    if (quiz == null) {
      print('[VideoTracker] Failed to generate quiz');
      return false;
    }

    print('[VideoTracker] Successfully generated quiz, showing to user');
    // Show the quiz
    if (context.mounted) {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => QuizScreen(
            quiz: quiz,
            userId: userId,
            videoContext: _recentVideos,
          ),
        ),
      );

      // After quiz is completed, start playback
      if (context.mounted) {
        // Use a small delay to ensure UI is ready
        await Future.delayed(const Duration(milliseconds: 100));
        // Restart the video playback after quiz is complete
        VideoFeedItem.startPlayback(context);
      }
    }

    print('[VideoTracker] Quiz completed, clearing video history');
    // Clear tracked videos after quiz
    _recentVideos.clear();
    return true;
  }

  List<VideoFeed> get recentVideos => List.unmodifiable(_recentVideos);
}



// lib/screens/quiz_screen.dart
// ================================================================================
import 'package:flutter/material.dart';
import 'dart:async';
import '../models/quiz_model.dart';
import '../services/quiz_service.dart';
import '../services/math_expression_service.dart';
import '../models/video_feed.dart';

class QuizScreen extends StatefulWidget {
  final Quiz quiz;
  final String userId;
  final List<VideoFeed>? videoContext;

  const QuizScreen({
    super.key,
    required this.quiz,
    required this.userId,
    this.videoContext,
  });

  @override
  _QuizScreenState createState() => _QuizScreenState();
}

class _QuizScreenState extends State<QuizScreen> {
  final QuizService _quizService = QuizService();
  final MathExpressionService _mathExpressionService = MathExpressionService();
  int _currentQuestionIndex = 0;
  final Map<String, String> _answers = {};
  final Map<String, bool> _isCorrect = {};
  bool _showExplanation = false;
  Timer? _timer;
  int _timeRemaining = 0;
  final TextEditingController _openEndedController = TextEditingController();
  final bool _showDebugInfo = true; // Add debug flag

  @override
  void initState() {
    super.initState();
    _initializeQuiz();
  }

  void _initializeQuiz() {
    setState(() {
      _timeRemaining = widget.quiz.timeLimit * 60;
    });
    _startTimer();
  }

  void _startTimer() {
    _timer = Timer.periodic(Duration(seconds: 1), (timer) {
      if (_timeRemaining > 0) {
        setState(() {
          _timeRemaining--;
        });
      } else {
        _submitQuiz();
      }
    });
  }

  Widget _buildContextHeader() {
    if (widget.videoContext == null) return const SizedBox.shrink();

    return Container(
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Based on your recent lessons:',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(height: 8),
          ...widget.videoContext!.map((video) => Padding(
                padding: const EdgeInsets.only(left: 8),
                child: Text(
                  '• ${video.title ?? "Untitled"}',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              )),
        ],
      ),
    );
  }

  Widget _buildQuestionCard(QuizQuestion question) {
    return Card(
      elevation: 4,
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (question.visualAid != null)
              Image.network(
                question.visualAid!,
                height: 200,
                fit: BoxFit.contain,
              ),
            Text(
              question.question,
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            if (question.type == QuestionType.multipleChoice)
              _buildMultipleChoiceOptions(question)
            else
              _buildOpenEndedInput(),
            if (_showExplanation && question.explanation != null)
              _buildExplanation(question),
            if (_showDebugInfo)
              Text(
                'Question ${_currentQuestionIndex + 1}/${widget.quiz.questions.length} '
                '(${question.difficulty})',
                style: const TextStyle(color: Colors.grey),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildMultipleChoiceOptions(QuizQuestion question) {
    return Column(
      children: question.options!.map((option) {
        final isSelected = _answers[question.id] == option;
        final showCorrect = _showExplanation;
        final isCorrect = option == question.correctAnswer;

        return ListTile(
          title: Text(option),
          leading: Radio<String>(
            value: option,
            groupValue: _answers[question.id],
            onChanged: _showExplanation
                ? null
                : (value) {
                    setState(() {
                      _answers[question.id] = value!;
                      _isCorrect[question.id] =
                          (value == question.correctAnswer);
                    });
                  },
          ),
          tileColor: showCorrect
              ? (isCorrect ? Colors.green.withOpacity(0.2) : null)
              : (isSelected ? Colors.blue.withOpacity(0.1) : null),
        );
      }).toList(),
    );
  }

  Widget _buildOpenEndedInput() {
    final question = widget.quiz.questions[_currentQuestionIndex];
    return TextField(
      controller: _openEndedController,
      decoration: InputDecoration(
        hintText: 'Enter your answer',
        border: OutlineInputBorder(),
      ),
      enabled: !_showExplanation,
      onChanged: (value) {
        _answers[question.id] = value;
        // For open-ended questions, we'll do a more flexible comparison
        _isCorrect[question.id] =
            _compareAnswers(value, question.correctAnswer);
      },
    );
  }

  bool _compareAnswers(String userAnswer, String correctAnswer) {
    final question = widget.quiz.questions[_currentQuestionIndex];

    if (question.type == QuestionType.mathExpression) {
      return _mathExpressionService.areExpressionsEquivalent(
          userAnswer,
          correctAnswer,
          question.expressionFormat!,
          question.acceptableVariations);
    }

    // Fall back to simple comparison for non-math questions
    return userAnswer.trim().toLowerCase() ==
        correctAnswer.trim().toLowerCase();
  }

  Widget _buildExplanation(QuizQuestion question) {
    final isCorrect = _isCorrect[question.id] ?? false;
    final userAnswer = _answers[question.id];
    final mistake = question.commonMistakes?[userAnswer];

    return Container(
      margin: EdgeInsets.only(top: 16),
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: isCorrect
            ? Colors.green.withOpacity(0.1)
            : Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            isCorrect ? 'Correct!' : 'Incorrect',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: isCorrect ? Colors.green : Colors.orange,
            ),
          ),
          SizedBox(height: 8),
          Text(
            'Explanation:',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          Text(question.explanation ?? 'No explanation available.'),
          if (!isCorrect && mistake != null) ...[
            SizedBox(height: 8),
            Text(
              'Common Mistake:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            Text(mistake),
          ],
        ],
      ),
    );
  }

  Future<void> _submitQuiz() async {
    _timer?.cancel();
    final timeSpent = Duration(seconds: (_timeRemaining ~/ 60).abs());

    int score = _isCorrect.values.where((correct) => correct).length;
    await _quizService.recordQuizAttempt(
      userId: widget.userId,
      quizId: widget.quiz.id,
      answers: _answers,
      isCorrect: _isCorrect,
      score: score,
      totalPossible: widget.quiz.questions.length,
      timeSpent: timeSpent,
    );

    // Show results dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: Text('Quiz Complete'),
        content: Text(
            'You scored $score out of ${widget.quiz.questions.length}\n'
            'Time taken: ${timeSpent.inMinutes}m ${timeSpent.inSeconds % 60}s'),
        actions: [
          TextButton(
            child: Text('Review Answers'),
            onPressed: () {
              Navigator.pop(context);
              setState(() {
                _showExplanation = true;
              });
            },
          ),
          TextButton(
            child: Text('Done'),
            onPressed: () {
              Navigator.pop(context);
              Navigator.pop(context); // Return to previous screen
            },
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.quiz.title),
        actions: [
          if (_showDebugInfo)
            IconButton(
              icon: const Icon(Icons.info_outline),
              onPressed: _showDebugDialog,
            ),
          Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Text(
                '${(_timeRemaining ~/ 60).toString().padLeft(2, '0')}:'
                '${(_timeRemaining % 60).toString().padLeft(2, '0')}',
                style:
                    const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          LinearProgressIndicator(
            value: (_currentQuestionIndex + 1) / widget.quiz.questions.length,
            backgroundColor: Colors.grey[200],
          ),
          _buildContextHeader(),
          Expanded(
            child: _buildQuestionCard(
                widget.quiz.questions[_currentQuestionIndex]),
          ),
          Padding(
            padding: EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                if (_currentQuestionIndex > 0)
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        _currentQuestionIndex--;
                        _showExplanation = false;
                      });
                    },
                    child: Text('Previous'),
                  )
                else
                  SizedBox(width: 80),
                Text(
                  '${_currentQuestionIndex + 1}/${widget.quiz.questions.length}',
                  style: TextStyle(fontSize: 16),
                ),
                if (_currentQuestionIndex < widget.quiz.questions.length - 1)
                  ElevatedButton(
                    onPressed: _answers[widget
                                .quiz.questions[_currentQuestionIndex].id] !=
                            null
                        ? () {
                            setState(() {
                              _currentQuestionIndex++;
                              _showExplanation = false;
                            });
                          }
                        : null,
                    child: Text('Next'),
                  )
                else
                  ElevatedButton(
                    onPressed: _answers[widget
                                .quiz.questions[_currentQuestionIndex].id] !=
                            null
                        ? _submitQuiz
                        : null,
                    child: Text('Submit'),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _showDebugDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Quiz Debug Info'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text('Quiz ID: ${widget.quiz.id}'),
              Text('Topics: ${widget.quiz.topics.join(", ")}'),
              Text('Difficulty: ${widget.quiz.difficulty}'),
              Text('Total Questions: ${widget.quiz.questions.length}'),
              Text('Time Limit: ${widget.quiz.timeLimit} seconds'),
              Text('Remaining Time: $_timeRemaining seconds'),
              if (widget.videoContext != null) ...[
                const Divider(),
                const Text('Video Context:'),
                ...widget.videoContext!.map((v) => Text(
                      '• ${v.title ?? "Untitled"} (${v.topics.join(", ")})',
                    )),
              ],
              const Divider(),
              Text('Current Question: ${_currentQuestionIndex + 1}'),
              Text('Selected Answers: ${_answers.values.join(", ")}'),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _timer?.cancel();
    _openEndedController.dispose();
    super.dispose();
  }
}



// lib/models/video_feed.dart
// ================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class VideoFeed {
  final String id;
  final String videoUrl;
  final String creatorId;
  final String description;
  final int likes;
  final int shares;
  final DateTime createdAt;
  final String learningPathId;
  final int orderInPath;
  final String title;
  final String topicId;
  final String subject;
  final String skillLevel;
  final List<String> prerequisites;
  final List<String> topics;
  final int estimatedMinutes;
  final bool hasQuiz;
  double progress;
  bool isCompleted;
  final Map<String, dynamic> videoJson;

  VideoFeed({
    required this.id,
    required this.videoUrl,
    required this.creatorId,
    required this.description,
    required this.likes,
    required this.shares,
    required this.createdAt,
    required this.learningPathId,
    required this.orderInPath,
    required this.title,
    required this.topicId,
    required this.subject,
    required this.skillLevel,
    required this.prerequisites,
    required this.estimatedMinutes,
    required this.hasQuiz,
    List<String>? topics,
    this.progress = 0.0,
    this.isCompleted = false,
    required this.videoJson,
  }) : topics = topics ?? [topicId];

  factory VideoFeed.fromFirestore(Map<String, dynamic> data, String id) {
    final List<String> topics = List<String>.from(data['topics'] ?? []);
    final String topicId = data['topicId'] ?? '';

    // If no topics are specified, use the single topic field
    if (topics.isEmpty && topicId.isNotEmpty) {
      topics.add(topicId);
    }

    return VideoFeed(
      id: id,
      videoUrl: data['videoUrl'] ?? '',
      creatorId: data['creatorId'] ?? '',
      description: data['description'] ?? '',
      likes: data['likes'] ?? 0,
      shares: data['shares'] ?? 0,
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      learningPathId: data['learningPathId'] ?? '',
      orderInPath: data['orderInPath'] ?? 0,
      title: data['title'] ?? '',
      topicId: topicId,
      subject: data['subject'] ?? '',
      skillLevel: data['skillLevel'] ?? '',
      prerequisites: List<String>.from(data['prerequisites'] ?? []),
      estimatedMinutes: data['estimatedMinutes'] ?? 5,
      hasQuiz: data['hasQuiz'] ?? false,
      topics: topics,
      progress: data['progress'] ?? 0.0,
      isCompleted: data['isCompleted'] ?? false,
      videoJson: data['videoJson'] ?? {},
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'videoUrl': videoUrl,
      'creatorId': creatorId,
      'description': description,
      'likes': likes,
      'shares': shares,
      'createdAt': createdAt.toIso8601String(),
      'learningPathId': learningPathId,
      'orderInPath': orderInPath,
      'title': title,
      'topicId': topicId,
      'subject': subject,
      'skillLevel': skillLevel,
      'prerequisites': prerequisites,
      'topics': topics,
      'estimatedMinutes': estimatedMinutes,
      'hasQuiz': hasQuiz,
      'progress': progress,
      'isCompleted': isCompleted,
      'videoJson': videoJson,
    };
  }
}



// lib/services/quiz_scheduler_service.dart
// ================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/quiz_model.dart';
import '../models/video_feed.dart';
import 'learning_progress_service.dart';
import 'quiz_service.dart';
import 'gpt_service.dart';

class QuizSchedulerService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final LearningProgressService _progressService = LearningProgressService();
  final QuizService _quizService = QuizService();
  final GptService _gptService = GptService();

  static const int _defaultQuestionCount = 10;
  static const double _recentTopicsWeight = 0.5;
  static const double _reviewTopicsWeight = 0.3;
  static const double _advancedTopicsWeight = 0.2;

  Future<List<QuizQuestion>> _getQuestionsForTopics({
    required List<String> topics,
    required int count,
    required DifficultyLevel difficulty,
  }) async {
    if (topics.isEmpty || count <= 0) {
      print('[QuizScheduler] No topics provided or count is 0');
      return [];
    }

    print(
        '[QuizScheduler] Searching for questions with topics: ${topics.join(", ")}');
    print('[QuizScheduler] Difficulty level: $difficulty');

    final quiz = await _gptService.generateQuizFromTopics(
      topics: topics,
      difficulty: difficulty,
      questionCount: count,
    );

    if (quiz == null) {
      print('[QuizScheduler] Failed to generate quiz questions');
      return [];
    }

    print(
        '[QuizScheduler] Successfully generated ${quiz.questions.length} questions');
    return quiz.questions;
  }

  Future<Quiz?> generateQuizForUser({
    required String userId,
    required List<String> currentTopics,
    List<VideoFeed>? previousVideos,
    int questionCount = _defaultQuestionCount,
  }) async {
    try {
      print('[QuizScheduler] Generating quiz for user: $userId');
      print('[QuizScheduler] Current topics: ${currentTopics.join(", ")}');

      final masteryLevels =
          await _progressService.getTopicMasteryLevels(userId);
      print('[QuizScheduler] User mastery levels: $masteryLevels');

      // If we have previous videos, extract their topics and context
      String? contextSummary;
      if (previousVideos != null && previousVideos.isNotEmpty) {
        final contextBuilder = StringBuffer();
        contextBuilder.writeln('Quiz based on your recent lessons:');

        for (var video in previousVideos) {
          contextBuilder.writeln('• ${video.title}');
          // Add topics from previous videos to current topics
          currentTopics.addAll(video.topics);
        }

        // Remove duplicates
        currentTopics = currentTopics.toSet().toList();
        contextSummary = contextBuilder.toString();
        print(
            '[QuizScheduler] Updated topics after adding from videos: ${currentTopics.join(", ")}');
      }

      // Calculate question distribution
      final recentCount = (questionCount * _recentTopicsWeight).round();
      final reviewCount = (questionCount * _reviewTopicsWeight).round();
      final advancedCount = (questionCount * _advancedTopicsWeight).round();

      print(
          '[QuizScheduler] Question distribution - Recent: $recentCount, Review: $reviewCount, Advanced: $advancedCount');

      // Adjust counts to ensure they sum to questionCount
      final totalCount = recentCount + reviewCount + advancedCount;
      final adjustment = questionCount - totalCount;
      final adjustedRecentCount = recentCount + adjustment;

      // Get questions for each category
      final difficulty = _getDifficultyForMastery(
        masteryLevels[currentTopics.last] ?? 0.0,
      );
      print('[QuizScheduler] Calculated difficulty level: $difficulty');

      print('[QuizScheduler] Getting recent questions...');
      final recentQuestions = await _getQuestionsForTopics(
        topics: currentTopics,
        count: adjustedRecentCount,
        difficulty: difficulty,
      );

      print('[QuizScheduler] Getting review questions...');
      final completedTopics = await _getCompletedTopics(userId);
      print('[QuizScheduler] Completed topics: ${completedTopics.join(", ")}');
      final reviewQuestions = await _getQuestionsForTopics(
        topics: completedTopics,
        count: reviewCount,
        difficulty: DifficultyLevel.intermediate,
      );

      print('[QuizScheduler] Getting advanced questions...');
      final upcomingTopics = await _getUpcomingTopics(currentTopics.last);
      print('[QuizScheduler] Upcoming topics: ${upcomingTopics.join(", ")}');
      final advancedQuestions = await _getQuestionsForTopics(
        topics: upcomingTopics,
        count: advancedCount,
        difficulty: DifficultyLevel.advanced,
      );

      // Combine all questions
      final allQuestions = [
        ...recentQuestions,
        ...reviewQuestions,
        ...advancedQuestions,
      ];

      print('[QuizScheduler] Total questions found: ${allQuestions.length}');
      if (allQuestions.isEmpty) {
        print('[QuizScheduler] No questions found for any category');
        return null;
      }

      // Create a new quiz
      return Quiz(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        title: previousVideos != null
            ? 'Quick Progress Check'
            : 'Progress Check Quiz',
        topics: [...currentTopics, ...completedTopics, ...upcomingTopics],
        difficulty: difficulty,
        questions: allQuestions,
        timeLimit: previousVideos != null
            ? 300
            : 900, // 5 minutes for quick quiz, 15 for regular
        shuffleQuestions: true,
        metadata: {
          'generatedFor': userId,
          'generatedAt': DateTime.now().toIso8601String(),
          'type': previousVideos != null ? 'video_progress' : 'adaptive',
          if (contextSummary != null) 'contextSummary': contextSummary,
        },
      );
    } catch (e, stackTrace) {
      print('[QuizScheduler] Error generating quiz: $e');
      print('[QuizScheduler] Stack trace: $stackTrace');
      return null;
    }
  }

  Future<List<String>> _getCompletedTopics(String userId) async {
    final progress = await _progressService.getUserProgress(userId);
    return List<String>.from(progress['topicsCompleted']?.keys ?? []);
  }

  Future<List<String>> _getUpcomingTopics(String currentTopic) async {
    final snapshot = await _firestore
        .collection('topics')
        .where('prerequisite', isEqualTo: currentTopic)
        .limit(3)
        .get();

    return snapshot.docs.map((doc) => doc.id).toList();
  }

  DifficultyLevel _getDifficultyForMastery(double mastery) {
    if (mastery < 0.4) return DifficultyLevel.beginner;
    if (mastery < 0.7) return DifficultyLevel.intermediate;
    return DifficultyLevel.advanced;
  }
}



// lib/services/audio_service.dart
// ================================================================================
import 'package:just_audio/just_audio.dart';

class AudioService {
  final AudioPlayer _audioPlayer = AudioPlayer();

  Future<void> playAudio(String script) async {
    // For testing, use a fixed audio URL.
    // In a real scenario you could convert `script` into an audio file URL via a TTS API.
    String audioUrl = 'https://www.example.com/audio/sample.mp3';
    await _audioPlayer.setUrl(audioUrl);
    await _audioPlayer.play();
  }

  Future<void> stop() async {
    await _audioPlayer.stop();
  }

  Future<void> dispose() async {
    await _audioPlayer.dispose();
  }
}



// lib/data/sample_videos.dart
// ================================================================================
final List<Map<String, dynamic>> sampleVideos = [
  // Algebra Basics Path Videos - Variables and Expressions Topic
  {
    'id': '19',
    'title': 'What are Variables?',
    'topicId': 'variables_expressions',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': [],
    'description': 'Introduction to variables and their use in algebra',
    'learningPathId': 'algebra_basics',
    'orderInPath': 1,
    'estimatedMinutes': 5,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 45,
    'shares': 12,
    'createdAt': DateTime.now().subtract(Duration(days: 19)),
  },
  {
    'id': '20',
    'title': 'Writing Simple Expressions',
    'topicId': 'variables_expressions',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': [],
    'description': 'Learn to write basic algebraic expressions',
    'learningPathId': 'algebra_basics',
    'orderInPath': 2,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 38,
    'shares': 8,
    'createdAt': DateTime.now().subtract(Duration(days: 20)),
  },
  {
    'id': '21',
    'title': 'Evaluating Expressions',
    'topicId': 'variables_expressions',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': ['variables_expressions'],
    'description': 'Practice evaluating expressions with different values',
    'learningPathId': 'algebra_basics',
    'orderInPath': 3,
    'estimatedMinutes': 7,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 42,
    'shares': 15,
    'createdAt': DateTime.now().subtract(Duration(days: 21)),
  },

  // Algebra Basics Path Videos - Equations Topic
  {
    'id': '22',
    'title': 'Introduction to Equations',
    'topicId': 'equations',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': ['variables_expressions'],
    'description': 'Learn what equations are and how they work',
    'learningPathId': 'algebra_basics',
    'orderInPath': 4,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 40,
    'shares': 10,
    'createdAt': DateTime.now().subtract(Duration(days: 22)),
  },
  {
    'id': '23',
    'title': 'Solving One-Step Equations',
    'topicId': 'equations',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': ['variables_expressions', 'equations'],
    'description': 'Master solving basic one-step equations',
    'learningPathId': 'algebra_basics',
    'orderInPath': 5,
    'estimatedMinutes': 7,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 37,
    'shares': 9,
    'createdAt': DateTime.now().subtract(Duration(days: 23)),
  },

  // Algebra Basics Path Videos - Inequalities Topic
  {
    'id': '24',
    'title': 'Understanding Inequalities',
    'topicId': 'inequalities',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': ['equations'],
    'description':
        'Learn what inequalities are and how they differ from equations',
    'learningPathId': 'algebra_basics',
    'orderInPath': 6,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 35,
    'shares': 8,
    'createdAt': DateTime.now().subtract(Duration(days: 24)),
  },
  {
    'id': '25',
    'title': 'Solving Simple Inequalities',
    'topicId': 'inequalities',
    'subject': 'algebra',
    'skillLevel': 'beginner',
    'prerequisites': ['equations', 'inequalities'],
    'description': 'Practice solving basic inequalities step by step',
    'learningPathId': 'algebra_basics',
    'orderInPath': 7,
    'estimatedMinutes': 7,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 33,
    'shares': 7,
    'createdAt': DateTime.now().subtract(Duration(days: 25)),
  },

  // Geometry Fundamentals Path Videos - Basic Shapes Topic
  {
    'id': '26',
    'title': 'Introduction to 2D Shapes',
    'topicId': 'basic_shapes',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': [],
    'description': 'Learn about basic two-dimensional shapes',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 1,
    'estimatedMinutes': 5,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 44,
    'shares': 11,
    'createdAt': DateTime.now().subtract(Duration(days: 26)),
  },
  {
    'id': '27',
    'title': 'Properties of Triangles',
    'topicId': 'basic_shapes',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': ['basic_shapes'],
    'description': 'Explore different types of triangles and their properties',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 2,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 41,
    'shares': 10,
    'createdAt': DateTime.now().subtract(Duration(days: 27)),
  },
  {
    'id': '28',
    'title': 'Properties of Quadrilaterals',
    'topicId': 'basic_shapes',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': ['basic_shapes'],
    'description':
        'Learn about squares, rectangles, and other four-sided shapes',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 3,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 39,
    'shares': 9,
    'createdAt': DateTime.now().subtract(Duration(days: 28)),
  },

  // Geometry Fundamentals Path Videos - Area and Perimeter Topic
  {
    'id': '29',
    'title': 'Understanding Perimeter',
    'topicId': 'area_perimeter',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': ['basic_shapes'],
    'description': 'Learn how to calculate perimeter of basic shapes',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 4,
    'estimatedMinutes': 5,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 36,
    'shares': 8,
    'createdAt': DateTime.now().subtract(Duration(days: 29)),
  },
  {
    'id': '30',
    'title': 'Finding Area of Rectangles',
    'topicId': 'area_perimeter',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': ['basic_shapes'],
    'description': 'Master calculating area of rectangles and squares',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 5,
    'estimatedMinutes': 6,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 34,
    'shares': 7,
    'createdAt': DateTime.now().subtract(Duration(days: 30)),
  },
  {
    'id': '31',
    'title': 'Finding Area of Triangles',
    'topicId': 'area_perimeter',
    'subject': 'geometry',
    'skillLevel': 'beginner',
    'prerequisites': ['basic_shapes', 'area_perimeter'],
    'description': 'Learn to calculate the area of different triangles',
    'learningPathId': 'geometry_fundamentals',
    'orderInPath': 6,
    'estimatedMinutes': 7,
    'hasQuiz': true,
    'videoUrl': '',
    'videoJson': {},
    'creatorId': 'teacher1',
    'likes': 32,
    'shares': 6,
    'createdAt': DateTime.now().subtract(Duration(days: 31)),
  }
];



// lib/services/speech_service.dart
// ================================================================================
import 'dart:convert';
import 'dart:io';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:http/http.dart' as http;
import 'package:just_audio/just_audio.dart';
import 'package:path_provider/path_provider.dart';
import 'package:crypto/crypto.dart';

class SpeechService {
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isInitialized = false;
  String? get _apiKey => dotenv.env['ELEVEN_LABS_API_KEY'];
  static const String _baseUrl = 'https://api.elevenlabs.io/v1';
  static const String _defaultVoiceId = 'pNInz6obpgDQGcFmaJgB'; // Adam voice
  File? _currentAudioFile;
  String? _selectedModelId;
  final Map<String, String> _audioCache = {};

  Future<void> initialize() async {
    if (!_isInitialized) {
      if (_apiKey == null) {
        throw Exception(
            'ELEVEN_LABS_API_KEY not found in environment variables');
      }
      await _fetchAvailableModels();
      await _initializeCache();
      _isInitialized = true;
    }
  }

  Future<void> _initializeCache() async {
    final cacheDir = await _getCacheDirectory();
    if (await cacheDir.exists()) {
      final files = await cacheDir.list().toList();
      for (var file in files) {
        if (file is File && file.path.endsWith('.mp3')) {
          final hash = file.path.split('/').last.replaceAll('.mp3', '');
          _audioCache[hash] = file.path;
        }
      }
    }
  }

  Future<Directory> _getCacheDirectory() async {
    final tempDir = await getTemporaryDirectory();
    final cacheDir = Directory('${tempDir.path}/audio_cache');
    if (!await cacheDir.exists()) {
      await cacheDir.create(recursive: true);
    }
    return cacheDir;
  }

  String _generateHash(String text) {
    return md5.convert(utf8.encode(text)).toString();
  }

  Future<String?> _getCachedAudioPath(String text) async {
    final hash = _generateHash(text);
    return _audioCache[hash];
  }

  Future<void> _cacheAudio(String text, List<int> audioBytes) async {
    final hash = _generateHash(text);
    final cacheDir = await _getCacheDirectory();
    final audioFile = File('${cacheDir.path}/$hash.mp3');
    await audioFile.writeAsBytes(audioBytes);
    _audioCache[hash] = audioFile.path;
  }

  Future<void> _fetchAvailableModels() async {
    try {
      final response = await http.get(
        Uri.parse('$_baseUrl/models'),
        headers: {
          'xi-api-key': _apiKey!,
          'Content-Type': 'application/json',
        },
      );

      if (response.statusCode == 200) {
        final models = json.decode(response.body);
        if (models is List && models.isNotEmpty) {
          _selectedModelId = models[0]['model_id'];
          print('Selected model: $_selectedModelId');
        }
      } else {
        print('Failed to fetch models: ${response.body}');
        _selectedModelId = 'eleven_multilingual_v2';
      }
    } catch (e) {
      print('Error fetching models: $e');
      _selectedModelId = 'eleven_multilingual_v2';
    }
  }

  Future<void> speak(String text, {String? preGeneratedMp3Url}) async {
    try {
      await initialize();

      // First, check if we have a pre-generated MP3 URL
      if (preGeneratedMp3Url != null && preGeneratedMp3Url.isNotEmpty) {
        print('Using pre-generated MP3 URL: $preGeneratedMp3Url');
        await _audioPlayer.setUrl(preGeneratedMp3Url);
        await _audioPlayer.play();
        return;
      }

      // Then, check if we have a cached version
      final cachedPath = await _getCachedAudioPath(text);
      if (cachedPath != null) {
        print('Using cached audio file: $cachedPath');
        await _audioPlayer.setFilePath(cachedPath);
        await _audioPlayer.play();
        return;
      }

      // If no cache or pre-generated URL, generate new audio
      if (_selectedModelId == null) {
        throw Exception('No text-to-speech model available');
      }

      print('Generating new audio from Eleven Labs API');
      final url = Uri.parse('$_baseUrl/text-to-speech/$_defaultVoiceId');
      final response = await http.post(
        url,
        headers: {
          'xi-api-key': _apiKey!,
          'Content-Type': 'application/json',
        },
        body: json.encode({
          'text': text,
          'model_id': _selectedModelId,
          'voice_settings': {
            'stability': 0.5,
            'similarity_boost': 0.75,
            'style': 0.0,
            'use_speaker_boost': true
          }
        }),
      );

      if (response.statusCode != 200) {
        print('API Response: ${response.body}');
        throw Exception('Failed to generate speech: ${response.body}');
      }

      // Cache the new audio
      await _cacheAudio(text, response.bodyBytes);

      // Get the cached file path
      final audioPath = await _getCachedAudioPath(text);
      if (audioPath == null) {
        throw Exception('Failed to cache audio file');
      }

      // Play the audio from the cached file
      await _audioPlayer.setFilePath(audioPath);
      await _audioPlayer.play();
    } catch (e) {
      print('Error in speak: $e');
      rethrow;
    }
  }

  Future<void> stop() async {
    await _audioPlayer.stop();
  }

  Future<void> pause() async {
    await _audioPlayer.pause();
  }

  Future<void> resume() async {
    await _audioPlayer.play();
  }

  Future<void> dispose() async {
    await stop();
    await _audioPlayer.dispose();
  }

  bool get isPlaying => _audioPlayer.playing;
}



